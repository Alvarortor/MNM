#Purpose: Pull a list of genes from all isolates file generated by Multiseqstracter or MegaMultiSeqstracter
#Usage: perl MegaMultiGenestracter.pl <genefile.txt> <isolatefile.txt>
#Make sure you only have one gene per line in gene file and one isolate per line in isolate file



#Imports
import os
import sys
import re


#Error file holder for app
myEF = "MMGSError.txt"
errpath = os.path.abspath(myEF)
errFile = open(errpath, "w+");

#Potential errors
noIn = "Error: Did not select isolate file."
noGene = "Error: No gene file specified"
noIsoFind = "Error: Could not find specified isolate"
noExist = "Error: File does not exist."
getHelp = "Use the -h option for help"
use = "MultiGeneStracter <GeneFile> <isolate_file> <file_modifier>"

#Error catches
iso_file = "none"
gene_file = "none"
my_mod = "none"


#inputs
try:
    iso_file = sys.argv[1]
    gene_file = sys.argv[2]
    my_mod = sys.argv[3]
except IndexError:
    if iso_file == "none":
        print("No isolate file specified")
        errFile.write(noIso)
        errFile.close()
        sys.exit()
    elif gene_file == "none":
        print("No gene file specified")
        errFile.write(noGene)
        errFile.close()
        sys.exit()
        
#Help section        
if iso_file == "-h" or gene_file == "-h" or my_mod == "-h":
    print("Purpose: Pull a list of genes from all isolates file generated by Multiseqstracter or MegaMultiSeqstracter\nUsage: perl MegaMultiGenestracter.py <genefile.txt> <isolatefile.txt> <modifier>\nMake sure you only have one gene per line in gene file and one isolate per line in isolate file")
    sys.exit()   
    
    
#Get path to the file
try:
    isopath = os.path.abspath(iso_file)
    isofile = open(isopath, 'r')
except FileNotFoundError:
    print (noIn, noExist, getHelp, use)
    errFile.write(noExist)
    errFile.close()
    sys.exit()     
#Get path to the file
try:
    genepath = os.path.abspath(gene_file)
    genefile = open(genepath, 'r')
except FileNotFoundError:
    print (noGene, noExist, getHelp, use)
    errFile.write(noExist)
    errFile.close()
    sys.exit()


#Lists
combocoords = list()
myFound = list()
myUnfound = list()
myErrs = list()
myData = list()
myGenes = list()


for gene in genefile:
    myGenes.append(gene.strip())
#Combine elements for easy searching
for iso in isofile:
    for gene in myGenes:
        combo = iso.strip() + "\t" + gene.strip()
        combocoords.append(combo)

isofile.close()
genefile.close()

#split entries for processing
for entry in combocoords:
    data = entry.split()
    myIso = data[0]
    myGene = data[1]
    if my_mod == "none":
        myFile = myIso + ".txt"
        myOF = myIso + "_pulled.txt"  
    else:
        myFile = myIso + my_mod + ".txt"
        myOF = myIso + my_mod + "_pulled.txt"

    IsoPath = os.path.abspath(myFile)
    IsoFile = open(IsoPath,'r')
    
    with open(IsoPath, 'r') as IsoFile:
        for line in IsoFile:
            if ">" in line:
                if myIso in line:
                    if myGene in line:
                        data = (line  + IsoFile.readline()) #Pulls header and sequence for matches
                        myData.append(str(data))
                        myFound.append(myIso + "\t" + myGene)
                    else:
                        myUnfound.append(myIso + "\t" + myGene)
            
            
#Open again to transfer
isopath = os.path.abspath(iso_file)
isofile = open(isopath)
for iso in isofile:
    iso = iso.strip() #Removes trailing newline
    if my_mod == "none":
        myOF = iso + "_pulled.txt"  
    else:
        myOF = iso + my_mod + "_pulled.txt"
    outfile = open(myOF,"w")
    for entry in myData: #Basically checks to see if we're using the correct isolate
        if iso in entry:
            outfile.write(entry)
            
err_signal = 0
#Checks for unfound
if len(set(myUnfound)) > 0:
    ErPath = os.path.abspath("MMGS_Errors.txt")
    ErrorFile = open(ErPath, "w");
    for element in set(myUnfound):
        if element not in set(myFound):
            err_signal += 1
            data = element.split()
            if my_mod == "none":
                fend = data[0] + ".txt"
            else:
                fend = data[0] + my_mod + ".txt"
            err_mess = str("Could not find " + data[1] + " for " + data[0] + " in " + fend)
            myErrs.append(str(err_mess))

#Cleans up and makes it alphabetical for error file
    myErrs.sort(reverse = False)
    for entry in myErrs:
        ErrorFile.write(entry + "\n")

if err_signal > 0:
    print("Could not find matches for all input genes. Generating error report")
    os.startfile("MMGS_Errors.txt")